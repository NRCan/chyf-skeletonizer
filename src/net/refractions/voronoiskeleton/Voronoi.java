/*
*
*  The Skeletonizer Utility is distributed under GNU General Public 
*  Licence – It is free software and can be  redistributed and/or 
*  modified under the terms of the GNU General Public License as 
*  published by the Free  Software Foundation; either version 2 of 
*  the License, or (at your option) any later version.
*
*  This program is distributed in the hope that it will be useful,
*  but comes WITHOUT ANY WARRANTY; without even the implied warranty 
*  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Please 
*  see the GNU General Public License for more details. 
*
*  You should have received a copy of the GNU General Public License 
*  along with this program; if this is not the case, please write to:
*
*  		            The Free Software Foundation, Inc.
*		                 59 Temple Place - Suite 330
*		   	                    Boston - MA
*		                     02111-1307 - USA.
*
*/


package net.refractions.voronoiskeleton;

import java.math.BigDecimal;
import java.util.ArrayList;

/*******************************************************************
 * Voronoi  	package: net.refractions.voronoiskeleton
 * 
 * @version Initial release
 * @author Brent Owens, David Blasby
 * 
 * Created September 2003
 * 
 * 
 * Description:
 * Voronoi generates a voronoi diagram of the points that are passed to it.
 * The algorithm used to generate the voronoi diagram is Fortune's sweepline algorithm.
 * 
 * Voronoi uses its own Point class that contains meta information used to generate skeletons. If you
 *   do not wish to use meta information, give each point any value for its meta information and use
 *   get_outputfull(). Or use package net.refractions.voronoi
 * 
 * A skeleton is a representation of the medial axis of a series of points. In this package, voronoi 
 *   was tailored to work with lakes that have river entry points. Each point is coded with a number
 *   that will specify if a segment is attached to a river entry point. If a segment is generated by
 *   two points that have different meta information, the segment is saved. Method get_output() will
 *   return these saved segments.
 * 
 * The points must be inserted into the voronoi diagram in order of lowest X value
 *   to highest X value, then lowest Y value to highest Y value. Method addPoint(Point p) does this for you.
 *   If you use addPointPreSorted(Point p), you must have the points pre sorted in that order.
 * 
 * Once the points have been inserted, the user should call run().
 * 
 * When run() has finished, the user can grab the voronoi segments by calling get_outputfull().
 *   This will return every segment. To obtain just the skeleton voronoi segments, call get_output().
 * 
 * The algorithm runs in approximately O(n^2) time with the average case being much less. To reduce
 *   the time complexity, the storage of the arc wave-fronts can be changed from a doubly linked list
 *   to a binary tree. This will reduce the time to O(n logn). However a performance increase might not
 *   be very noticable.
 * 
 ******************************************************************/
final public class Voronoi 
{	
		// this is for the enhance precision math enhancements
	public static final int NEVER = 0;
	public static final int SOMETIMES = 1;
	public static final int ALWAYS = 2;
	
	
	boolean		noOutsideEdges = false; //for clipping.  If a segment is completely ouside the bounding box, then
	                                    //  it will be removed. 
	 
	int keptCount = 0;   				// debugging code
	
	EventQueue 	siteEventQ;   			// sorted list of circle events
	PointQueue 	pointListQ;				// sorted list of point events (site points)
	
	EventHash	eventHash;   			// hash table for all the events    
	SegmentHash	segHash;     			// hash table for all the segments.  Every single segment
	ArcHash		arcHash;     			// hash table for all the arcs
	
	Arc 		arcRoot;  				// root of the parabolic front (lowest Y value or null)
	
			
	Point		firstPoint;				// used to remove duplicate end point. This occurs in many polygon geometries 
										//	 where the start and end points are the same. Only used when adding in
										//   points to the voronoi (before .run()).  
			 							// Not used if you're adding in points in a pre-sorted manner
			 							
	boolean firstRun; 					// For formation of the bounding box.  true means that the point being inserted
										//   is the first point in the voronoi diagram.  Ignore this.
	
	ArrayList	skeletonSegsHK;  		// a list of segments forming a subset of segHash.  Enhanced output (segHash 
										//   minus unimportant edges). This list contains all the segment's hash keys 
										//   that are to be kept for skeletonization output.
	
	int useEnhancedPrecisionCircle = SOMETIMES; 	// true means will go slow.  BigDecimal calculations in circle formation  
												//   false means use doubles in circle formation.  If the circle is very
												//   big, then will use the enhanced precsion
	 
	int useEnhancedPrecisionIntersect = SOMETIMES; 	// true means will go slow.  BigDecimal calculations in intersection  
													//   formation false means use doubles. 
	
	// bounding box coords
	double bb_x0 = 0;  	// xmin
	double bb_x1 = 0;  	// xmax
	double bb_y0 = 0;  	// ymin
	double bb_y1 = 0; 	// ymax
	
	
	boolean returnAll = false; 			// for .getOutput().  
										//   if true, return all the segments (ie. segHash)
										//   if false, then return only the "important ones". (ie. skeletonSegsHK)
			
	boolean DEBUG = false; 				// debugging info printing on/off
	

	/*******************************************************************
	 * @param returnAll Return every segment in the output, not just the valid skeleton segments.
	 * @param circleEnhanced Use enhanced precision (BigDecimal). Warning! much slower.
	 * @param intersectEnhanced Use enhanced precision (BigDecimal). Warning! much slower.
	 * 
	 * Constructor. Initializes all the data structures and variables for Voronoi.
	 ******************************************************************/
	public Voronoi(boolean returnAll,int circleEnhanced, int intersectEnhanced)
	{
		siteEventQ = new EventQueue();
		pointListQ = new PointQueue();
		eventHash = new EventHash();
		segHash = new SegmentHash();
		arcHash = new ArcHash();
		noOutsideEdges = true;
		skeletonSegsHK = new ArrayList();
		firstRun = true;							// this will be set to false when the first point has been inserted
		this.returnAll = returnAll;
		this.useEnhancedPrecisionCircle = circleEnhanced;
		this.useEnhancedPrecisionIntersect = intersectEnhanced;
	}
		
	
	
	/*******************************************************************
	 * @param p
	 * 
	 * Inserts a point into the point priority queue. It assumes that the user is inputting them
	 * in the correct priority order.
	 ******************************************************************/
	public void addPointPreSorted(Point p)
	{
		pointListQ.insertSorted(p);
		if (firstRun)
		{
			bb_x0 = p.x;
			bb_x1 = p.x;
			bb_y0 = p.y;
			bb_y1 = p.y;
			firstRun = false;
		}
		//System.out.println("x=" + p.x + ", y=" + p.y);
		// Keep track of bounding box size.
		if (p.x < bb_x0) bb_x0 = p.x;
		if (p.y < bb_y0) bb_y0 = p.y;
		if (p.x > bb_x1) bb_x1 = p.x;
		if (p.y > bb_y1) bb_y1 = p.y;
				
	}
	
	
	/*******************************************************************
	 * @param p The point that is to be inserted into the list of voronoi-determining points.
	 * 
	 * addPoint will keep track of the min and max X and Y values and create a bounding box 
	 * of the points. Currently this bouinding box is ignored.
	 ******************************************************************/
	public void addPoint(Point p)
	{
		/*	// uncomment this section to allow for first (duplicate) point removal
		if (pointListQ.root != null)
			if (p.x == pointListQ.root.x && p.y == pointListQ.root.y)
				return;
		*/
		if (pointListQ.size() == 0)
			firstPoint = p;
		else
		{
			if (firstPoint != null)
				if (p.x == firstPoint.x && p.y == firstPoint.y)
					return;
		}
		
		pointListQ.insert(p);		// insert the point into the queue

		if (firstRun)				// if this is the first point being inserted, initialize the bounding box and 
		{							//   set first run to false
			bb_x0 = p.x;
			bb_x1 = p.x;
			bb_y0 = p.y;
			bb_y1 = p.y;
			firstRun = false;
		}
		//System.out.println("x=" + p.x + ", y=" + p.y);
		// Keep track of bounding box size.
		if (p.x < bb_x0) bb_x0 = p.x;
		if (p.y < bb_y0) bb_y0 = p.y;
		if (p.x > bb_x1) bb_x1 = p.x;
		if (p.y > bb_y1) bb_y1 = p.y;

			
	}

	
	
/***********************************************************************************
 * Calculate the voronoi diagram with the existing points that were added with addPoint(Point p).
 * 
 *  While (there are points and circle events to process)
 *     get first action (point or event with lowest x value, events get priority over points if x's are equal) 
 *     process the point or event
 * 
 * 
 *  Main entry.
 **********************************************************************************/
	public void run()
	{
		if (DEBUG)
		  System.out.println("RUNNING VORONOI");
		
		while (pointListQ.size() > 0)
		{
			// if the next event type to process is an event(circle) and not a point
			
			 // if things in the siteEventQueue and it ahead of the 1st point in the pointevent queue, then 
			 //  handle this circle event.
			if (siteEventQ.size()>0 && 
			((Event)eventHash.get(((Event)siteEventQ.peak()).hk)).x_pos <= pointListQ.peak().x)
				process_event();
			else
				process_point();
		}
		

		// we have finished inserting the regular points, now finish with the leftover circle points
		while (siteEventQ.size()>0)
		{
			process_event();
		}
		
	 	if (DEBUG)
	 		System.out.println("FINSHED VORONOI - cleaning edges");
	 		
		//GeometryUtil.write_shape("c:\\before_finish_edges.shp",
		//	(Segment[]) this.get_outputfull().toArray( new Segment[0]) );
		
		finish_edges(); // Clean up dangling edges.
	}
	
	
	/***********************************************************************************
	 * Remove the point from the list and insert it into the list of arc fronts
	 **********************************************************************************/
	private void process_point()
	{
		//System.out.println("process_point");
		
		// doesn't use a pointer to do this, so the code below is correct
		// Get the next point from the queue.
		Point p = (Point)pointListQ.pop();
		
		// Add a new arc to the parabolic front.
		parabolicFront_insert(p);
	}
		
	
	/***********************************************************************************
	 * Grab the first event off the queue and finish off the closing arc associated
	 * with it.
	 * 
	 *  When the scan line hits a circle event (at the extream right part of circle), we:
	 *   	terminate event
	 *   	create a new segment starting at the circle center (where this arc disappears)
	 *   	close off arc
	 *   	finish the 2 segments associated with the arc (terminate at circle centre)
	 *   
	 * What is a circle event:
	 * 	A circle event is a location where two parabolic arcs overtake another arc trapped between them.
	 * <pre> <code>
	 *    __
	 * 		\
	 * 	a	 \
	 * 		  \
	 * 	__     |
	 *	  `	  /
	 * 	   \ /
	 * 	b   X			<-- Arc b is overtaken at point X (this is a circle center)
	 *     / \
	 * 	__,	  \
	 * 		   \
	 * 			\
	 * 	c		 |
	 * 		    /
	 * 		   /
	 * 		  /
	 * </code></pre>
	 * 
	 * It is important to note the difference between the circle center and the X position of the circle.
	 * 		The circle center is the point where the arc is overtaken.
	 * 		The X position is the extreme right x-value of the circle. This is where the sweep line is when the event 
	 *      should be called.
	 * 
	 * 
	 * When a circle event is called and the arc is closed off, the relative segments must also be closed off and a new
	 *  one created.
	 * <pre><code>
	 * 
	 * 		BEFORE												AFTER
	 * 
	 *      \        arc a									\
	 * 		 \												 \				a.s0
	 * 		  \	  <-- a.s0									  \				  |
	 *   	   \											   \			 \|/
	 *    		\											    \			  `
	 *    	     \											     \
	 * arc b	  X		<-- termination point				      .--------------------		<-- new segment
	 *           /											     /			 
	 *          /											    /			 .
	 * 	       /   <-- c.s1									   /			/|\	 
	 * 		  /												  /				 |
	 *       /    arc c										 /				c.s1
	 *      /										
	 * </code></pre>
	 * 
	 **********************************************************************************/
	private void process_event()
	{
		Event e = (Event)eventHash.remove(siteEventQ.root.hk);  // pop the event off the event queue

		if (DEBUG)
			System.out.println("Handling event "+ e);
	
		siteEventQ.pop();  				// remove the event from the list
		
		if (e.valid)  
		{// sometimes we superseed circle events (events get replaced by other, sooner, events) - this handles that
			
			// Start a new edge.
			Segment s = new Segment(e.point);          	// create a new segment starting at the circle center (e.point)
			s.hk = new HashKey(segHash.getNewKey());   	// grab a new hash key
			s.trashMe = false;							// initialize it to be kept
			segHash.put(s.hk, s);						// add to complete list of segments
			Arc refAip = e.arc.prev;					// the previous arc to the arc associated with the event e
			Arc refAin = e.arc.next;					// the next arc to the arc associated with the event e
			Arc refAi  = e.arc;							// the current arc to the arc associated with the event e
			s.refPointA = refAip.point;					// one of the points that generated the voronoi segment
			s.refPointB = refAin.point;					// the other point that generated the voronoi segment
			
			
			
			// if the difference between the meta values of the two generating points is 1, then this is a segment 
			//   that forms a skeleton and the segment should be kept. This case is the actual river entry point
			if (Math.abs(refAip.point.metaInfo - refAin.point.metaInfo) == 1)
			{
				s.keepMe = true;						// Flag the segment to be kept, used outside the voronoi class
				keptCount++;							// Increase the counter of kept (skeleton) segments.
														//   This is for debugging
				skeletonSegsHK.add(s.hk);				// Add this segment to the output list of valid skeleton
														//   segments
			}
			else if (refAin.point.metaInfo == refAip.point.metaInfo)   	
				s.trashMe = true; 		// if the meta values are the same, then this isn't part of the skeleton
			else						// else, this is a possible skeleton to be checked later outside of this class.
				skeletonSegsHK.add(s.hk);		//   don't mark it as keepMe(true) because it isn't a river entry point
		
		
			
			// Remove the associated arc from the arc wave front. This is a linked list removal
			Arc a = e.arc;
			if (a.prev != null)
			{
				Arc ap = a.prev;
				Arc an = a.next;
				ap.next = an;
				ap.s1 = s;     // this happens because its old segment is now finished, we track the new one
			}
			if (a.next != null)
			{
				Arc an = a.next;
				Arc ap = a.prev;
				an.prev = ap;
				an.s0 = s;    // old segment is now finished, want to track the new one
			}
			
			// Finish the edges before and after a.
			if (a.s0 != null)
			{
				Segment sx0 = a.s0;     
				sx0.finish(e.point);  	//finish--> sx0 is enpointed at e.point
			}
			if (a.s1 != null)
			{
				Segment sx1 = a.s1;
				sx1.finish(e.point);	//finish--> sx1 is enpointed at e.point
			}
			
			// It is possible that a new circle event is created with the removal of an arc front. 
			//   Therefore Recheck circle events on either side of p:
			if (a.prev != null) // if it is not at the start of the list
			{
				check_circle_event( a.prev, e.x_pos);  // check for the circle event on my edge at this scan line
			}
			if (a.next != null)	// if it is not at the end of the list
			{
				check_circle_event(a.next, e.x_pos);	// check for the circle event on my edge at this scan line
			}
			
		}// end if e is a valid point
	}
	
	
	
	
	/*******************************************************************
	 * @param p point to be intersected
	 * @return Arc,intersectionpoint. Returns null if it doesnt hit any arcs.
	 * 
	 * Look through the current parabolic front and see where this point intersects.
	 * We draw a horizontal line (y = p.y) and see which arc it actually hits.
	 * 
	 * this is O(n), where n=# of arcs in parabolic front.
	 ******************************************************************/
	private Object[] findIntersectingArc(Point p)
	{
				// scan through the front, starting at root (smallest y)
					
		Arc current = (Arc)arcHash.get(arcRoot.hk);
		while( current != null)
		{
				// this projects the point p horizontally in the -x direction
				// if z intersects current arc, then this will be non-null
				// and it's the point of intersection (line and arc).
				//  
				//  scan line is at p.x
			Point z = intersect(p,current);
			if (z!=null)
			{
				Object[] os = new Object[2];
				os[0] = current;			// the arc it intersects with
				os[1] = z;					// the point of intersection
				return os;
			}
			current = current.next;
		}
		return null;
	}
	
	
   /***********************************************************************************
	 * @param p The point that is going to be inserted.  Actually p is generating a new arc that is going to be inserted
	 * 
	 * Inserts the new arc front into the list of arcs that currently exist.
	 * It will perform parabolic intersections with the existing arcs and split the one it intersects.
	 * 
	 * 
	 *  1. if the arc list is empty
	 *        simple case - add the new arc to the parabolic front
	 *        finished
	 * 
	 *  2.  get the arc that the point intersects
	 * 
	 *   if it doesnt hit an arc, then   (special case)
	 *      stick the arc at the top (high y) of the arc list and return
	 * 
	 *   split the hitArc into 3 -> hitArc (low), new Arc (middle), hitArc (high)
	 * 
	 * <pre><code>
	 * 			
	 * 			BEFORE									AFTER
	 * 
	 * 			new point								new arc
	 * 				|										|
	 *    __		|		_____					__		|		_____
	 * 		\	   \|/		  |						  \	   \|/		 arc a
	 * 		 \	    `		  |						   \	`		__|__
	 * 		  \		X		  |						    p------X	__|__<-- arc c
	 * 	   a   |		     arc a					a    |			  |
	 *	  	  /				  |						    /			 arc a
	 * 	     /  			  |						   /			  |
	 *      /__				__|__					  /__			__|__
	 * 	 __/   \			  |					   __/   \			  |
	 * 		    \			  |						      \			  |
	 * 			 \			  |						       \		  |
	 * 		b	  |			 arc b					b       |		 arc b
	 * 		     /			  |						       /		  |
	 * 		    /			  |						      /			  |
	 * 		 __/			__|__					   __/			__|__
	 * 	   
	 * </code></pre>
	 * 
	 *   We then maintain the segments associated with 
	 *   The arcs are kept in a double-linked list based on ymin to ymax.
	 **********************************************************************************/
	private void parabolicFront_insert(Point p)
	{
	
		if (DEBUG)
			System.out.println("parbolic front insert "+p);
			
			
		//simple case, nothing in the parabolic front, so we can just make a single arc
		if (arcRoot == null) 
		{				
		  	arcRoot = new Arc(p);
		  	arcRoot.hk = new HashKey(arcHash.getNewKey());
		  	arcHash.put(arcRoot.hk, arcRoot);
		  	return;
		}
		
		// if we made it to here, that means that there are arcs in the parabolic arc-front list
		
		// Find the arc that the new point intersects with 
		Object[] os = findIntersectingArc(p);		// this array contains the intersected arc and the point 
													//   where it intersected
		
		
		// rare case - doesnt hit anything in the front.  This will happen
		// when the first points in the front are all exactly vertically aligned.
		//  dont generate any circle events.
		if (os == null)
		{
			// we are in here because the inserted point is vertically alligned withthe rest in the list 
			//   and does not intersect it.
			
			//NOTE: it is assumed that the points are inserted from least x to greatest x, then least y to greatest y
			
			//System.out.println("          + parabolicFront_insert -- point doesnt hit any arcs, inserting at end");
			
			//create new arc
			Arc a = new Arc(p);
			a.hk = new HashKey(arcHash.getNewKey());
			arcHash.put(a.hk, a);					// add the arc to the arc hash
			
			Arc current = arcRoot;					// current will be the last arc in the list of arcs
			
			//find end of the parabolic front
			while (current.next != null)
			{
				current = current.next;
			}
			current.next = a;						// set the current arc to be the one just inserted (onto 
													//   the top of the list)
			a.prev = current;				
							
			//a and a.prev are vertically aligned
			
		    //segment anchor based on the mid point between the two points
		    Point p_anchor = new Point (bb_x0, (p.y+a.prev.point.y)/2.0 );
		    Segment seg = new Segment(p_anchor);
		    a.s0 = seg;								// set the new arc's segment, associated with a.prev (s0), to seg
		    a.prev.s1 = seg;						// set the previous arc's segment, associated with a (s1), to seg
		    seg.hk = new HashKey(segHash.getNewKey());
		    segHash.put(seg.hk, seg);
		    
		    // put point information onto the segment (the two points that cause the generation of this segment)
		    seg.refPointA = current.point; 			// a.prev
		    seg.refPointB = p; 						// the newly inserted point
			
			// if the difference between the two point's meta information is 1, they they are at a river entry point 
			if (Math.abs(current.point.metaInfo - p.metaInfo) == 1)
			{
				seg.keepMe = true;
				keptCount++;
				skeletonSegsHK.add(seg.hk);
			}
			else if (current.point.metaInfo == p.metaInfo)	
					seg.trashMe = true;				// if they have the same meta numbers, they aren't to be kept at all
			else									// whether or not they should be kept is to be determined later
				skeletonSegsHK.add(seg.hk);			//   for now, just save them to the output
											
			return;									// we are done so don't continue
		}
		
		// There was an intersection, therefore insert the arc into the arc list.
		// We do this by removing the current arc, then adding in 3 new arcs
		
		//  orginalarc there was the 'hitArc' edge. Now will be: hitArc, new arc, hitArc 
		
		// this code shouldnt be here - we should refactor it out into a class to
		// maintain the parabolic front.  (ie. make arc and arc=list classes)
		
		Arc hitArc = (Arc) os[0];
		Point intersectionPoint = (Point) os[1];
		
		
		// hitArc is duplicated first, then we link the 3 back up
		//   top = copyofhitArc   (takes s1 from the original arc).
		//   middle = newArc
		//   bottom  = hitArc
		Arc next = hitArc.next;
		
		Arc copyOfHitArc = new Arc(hitArc.point);
		copyOfHitArc.s1 = hitArc.s1;
		
		copyOfHitArc.hk = new HashKey(arcHash.getNewKey());
		arcHash.put(copyOfHitArc.hk, copyOfHitArc);
		Arc newArc = new Arc(p); 					// based on the new point (arc) being inserted
		newArc.hk = new HashKey(arcHash.getNewKey());
		arcHash.put(newArc.hk, newArc);
		
		copyOfHitArc.next = next;
		copyOfHitArc.prev = newArc;
		
		newArc.next = copyOfHitArc;
		newArc.prev = hitArc;
		
		hitArc.next = newArc;
		
		//copyOfHitArc is the top arc, so we check to see if it has a next
		if (copyOfHitArc.next != null) 			// link in the points above the top inserted one so it points down again
			copyOfHitArc.next.prev = copyOfHitArc; 
		
		
		// newArc is now the current arc that we will be working with from here on down
		
		
		// Create two new segments.
		//   one with respect to ME and upper arc
		//   other with respect to ME and lower arc
		// In both cases, they have the intersection point as an ancor (this point doesnt change over time)
		// The other point of the segments will change over time as the sweep plane moves.
		
		Segment newSegment1 = new Segment(intersectionPoint);
		Segment newSegment2 = new Segment(intersectionPoint);
		
		newSegment1.hk = new HashKey(segHash.getNewKey());
		segHash.put(newSegment1.hk, newSegment1);		
		newSegment2.hk = new HashKey(segHash.getNewKey());
		segHash.put(newSegment2.hk, newSegment2);
			
			
		//code the new segments
		Arc refAip = newArc.prev;
		Arc refAin = newArc.next;
		Arc refAi  = newArc;

		if (Math.abs(refAip.point.metaInfo - refAi.point.metaInfo) == 1)	// a river entry point
		{
			newSegment1.keepMe = true;
			keptCount++;
			skeletonSegsHK.add(newSegment1.hk);
		}
		else if (refAip.point.metaInfo == refAi.point.metaInfo)				// not needed at all for skeletons
				newSegment1.trashMe = true;
		else																// possible skeleton
			skeletonSegsHK.add(newSegment1.hk);
		newSegment1.refPointA = refAip.point;								// save the reference points in the segment
		newSegment1.refPointB = refAi.point;

		if (Math.abs(refAin.point.metaInfo - refAi.point.metaInfo) == 1)	// a river entry point
		{
			newSegment2.keepMe = true;
			keptCount++;
			skeletonSegsHK.add(newSegment2.hk);
		}
		else if (refAin.point.metaInfo == refAi.point.metaInfo)				// not needed at all for skeletons
			newSegment2.trashMe = true;
		else																// possible skeleton
			skeletonSegsHK.add(newSegment2.hk);
		newSegment2.refPointA = refAi.point;								// save the reference points in the segment
		newSegment2.refPointB = refAin.point;

	
		
		if (newArc.prev != null)    										// assign the segment (top segment)
			newArc.prev.s1 = newSegment1;
		newArc.s0 = newSegment1;
	
		if (newArc.next != null) 											// assign the segment (bottom segment)
			newArc.next.s0 = newSegment2;
		newArc.s1 = newSegment2;
		

	    check_circle_event(newArc, p.x);									// check for a new circle event  -  current
	    
	    if (newArc.prev != null) 											// check for a new circle event  -  previous
			check_circle_event(newArc.prev, p.x);
		if (newArc.next != null) 											// check for a new circle event	 -  next
			check_circle_event(newArc.next, p.x);
			
	}
		
		
	
	/*******************************************************************
	 * @param a previous
	 * @param b current
	 * @param c next
	 * @return
	 ******************************************************************/
	private double[] circleEnhancedPrecision(Point a, Point b, Point c)
	{
		BigDecimal a_x = new BigDecimal(a.x);
		BigDecimal a_y = new BigDecimal(a.y);
		
		BigDecimal b_x = new BigDecimal(b.x);
		BigDecimal b_y = new BigDecimal(b.y);
		
		BigDecimal c_x = new BigDecimal(c.x);
		BigDecimal c_y = new BigDecimal(c.y);
		
	

		//((b.x-a.x)*(c.y-a.y) - (c.x-a.x)*(b.y-a.y) > 0)
		
		BigDecimal temp1 = ( b_x.subtract(a_x) ).multiply(  c_y.subtract(a_y)    );
		BigDecimal temp2 = ( c_x.subtract(a_x) ).multiply(  b_y.subtract(a_y)    );
	
		int signum = temp1.subtract(temp2).signum();
		// Check that bc is a "right turn" from ab.
		if ( signum > 0)
		{
			//System.out.println("circle -> null");
			return null;
		}


	/*
		// Algorithm from O'Rourke 2ed p. 189.
		double 	A = b.x - a.x,
				B = b.y - a.y,
				C = c.x - a.x,
				D = c.y - a.y,
				E = A*(a.x+b.x) + B*(a.y+b.y),
				F = C*(a.x+c.x) + D*(a.y+c.y),
				G = 2*(A*(c.y-b.y) - B*(c.x-b.x));
	*/
			BigDecimal A = b_x.subtract(a_x);
			BigDecimal B = b_y.subtract(a_y);
			BigDecimal C = c_x.subtract(a_x);
			BigDecimal D = c_y.subtract(a_y);
			
			BigDecimal t1 = a_x.add(b_x);
			BigDecimal t2 = a_y.add(b_y);
			
			BigDecimal E = A.multiply(t1).add( B.multiply(t2));
			
			BigDecimal t3 = a_x.add(c_x);
			BigDecimal t4 = a_y.add(c_y);
			
			BigDecimal F = C.multiply(t3).add( D.multiply(t4));
			
			BigDecimal t5 = c_y.subtract(b_y);
			BigDecimal t6 = c_x.subtract(b_x);
			BigDecimal t7 = new BigDecimal("2");
			
			BigDecimal G = A.multiply(t5).subtract( B.multiply(t6)  ).multiply(t7);
	
		if (G.signum() == 0) 
			return null;  // Points are co-linear.
	
		// Point o is the center of the circle.
		//double px = (D*E-B*F)/G;
		//double py = (A*F-C*E)/G;
		
		BigDecimal t8 = D.multiply(E).subtract( B.multiply(F)  );
		BigDecimal px = t8.divide(G,t8.scale()+G.scale()+20,BigDecimal.ROUND_HALF_EVEN );
		
		BigDecimal t9 = A.multiply(F).subtract(C.multiply(E));
		BigDecimal py = t9.divide(G,t9.scale()+G.scale()+20,BigDecimal.ROUND_HALF_EVEN );
		
		//x = px + Math.sqrt( (a.x - px)*(a.x - px) + (a.y - py)*(a.y - py) );	// a^2 + b^2
		
		BigDecimal t10 = a_x.subtract(px);
		t10 = t10.multiply(t10);
		
		BigDecimal t11 = a_y.subtract(py);
		t11 = t11.multiply(t11);
		
		BigDecimal t12 = t10.add(t11);
		
		BigDecimalSQRT bdsqrt = new BigDecimalSQRT();
		
		
		BigDecimal x = px.add(   bdsqrt.get(t12)    );
		
	
		// o.x plus radius equals max x coordinate.
		double value[] = new double[3];
		value[0] = px.doubleValue();
		value[1] = py.doubleValue();
		value[2] = x.doubleValue();

		if (DEBUG)
			System.out.println("circle called on points ["+a+","+b+","+c+"] -> ("+px+","+py);
			
		return value;
	}
	
	

	/*******************************************************************
	 * @param a previous
	 * @param b	current
	 * @param c next
	 * @return
	 * 
	 * Will decide whether or not to use enhanced precision (slow) or innacurate precision.
	 ******************************************************************/
	private double[] circle(Point a, Point b, Point c)
	{
		if (useEnhancedPrecisionCircle == ALWAYS)
			return circleEnhancedPrecision(a,b,c);
		else if (useEnhancedPrecisionCircle == SOMETIMES)
			return circleInaccurate(a,b,c,true);  // still might use enhanced!
		else
			return circleInaccurate(a,b,c,false);  // never use enhanced!
	}



	/*******************************************************************
	 * 
	 *  Will use the enhanced version if needed!
	 * 
	 * @param a First point
	 * @param b	Second point
	 * @param c Third point
	 * @param adapativePrecision  false = never use enhanced precision, true = sometime use enhanced precision
	 * @return An array, of size 3, of values: array[0] = new x coordinate, 
	 *
	 *   array[1] = new y coordinate, array[2] = max x coordinate of the circle
	 ******************************************************************/
	private double[] circleInaccurate(Point a, Point b, Point c,boolean adapativePrecision)
	{
		double x;
		

		// Check that bc is a "right turn" from ab.
		if ((b.x-a.x)*(c.y-a.y) - (c.x-a.x)*(b.y-a.y) > 0)
		{
			//System.out.println("circle -> null");
			return null;
		}

		// Algorithm from O'Rourke 2ed p. 189.
		double 	A = b.x - a.x,
				B = b.y - a.y,
				C = c.x - a.x,
				D = c.y - a.y,
				E = A*(a.x+b.x) + B*(a.y+b.y),
				F = C*(a.x+c.x) + D*(a.y+c.y),
				G = 2*(A*(c.y-b.y) - B*(c.x-b.x));
	
		if (G == 0) 
			return null;  // Points are co-linear.
	
		// Point o is the center of the circle.
		double px = (D*E-B*F)/G;
		double py = (A*F-C*E)/G;
	
		// o.x plus radius equals max x coordinate.
		x = px + Math.sqrt( (a.x - px)*(a.x - px) + (a.y - py)*(a.y - py) );	// a^2 + b^2
		double value[] = new double[3];
		value[0] = px;
		value[1] = py;
		value[2] = x;

		if ((adapativePrecision) && ((Math.abs(px)> 100000000) || (Math.abs(py)> 100000000)|| (Math.abs(x)> 100000000) ||(Math.abs(E) > 100000000) || (Math.abs(F) > 100000000) || (Math.abs(G) > 100000000) ))
		{
			return circleEnhancedPrecision( a,  b,  c);
		}
	
		return value;
	}
	
	
	
	/*******************************************************************
	 * @param i The arc that is going to be inspected for circle events
	 * @param x0 The current x value of the sweep line
	 * 
	 * Looks for a new circle event around arc i. The arc's neighbours are checked 
	 * and if an event is detected, it is created and added to the event queue.
	 * 
	 * Checks if 3 points given by i.prev, i, i.next make a circle.  If it's a usefull
	 *   circle (event is going to affect arcs being overtaken), we stick it on the event queue for later processing.
	 ******************************************************************/
	private void check_circle_event(Arc i, double x0)
	{	
		Arc ax = i;
		if (ax.event != null)  					//already have one, mark it as unneeded
		{
			Event ex = ax.event;
			if (ex.x_pos != x0)
			{
				ex.valid = false;
			}
			else
			{
				//TODO look at here if there's already an event at x0
				if (DEBUG)
					System.out.println("check_circle_event:: already an event at x0 - killing it");
				return;
			}
		}
		ax.event = null;  						//kill any existing event
		
		if (ax.prev == null || ax.next == null)	//return early because there isn't a neighbour on one or both sides.
			return;
		

		Arc axp = ax.prev;
		Arc axn = ax.next;
		double[] ret = circle(axp.point, ax.point, axn.point);  // find the circle defined by the 3 site points
		
		if (ret != null)   						// circle exists
		{
			double px = ret[0];
			double py = ret[1];
			double x =  ret[2];
			if (Math.abs(x-x0)<10E-5)   // precision error?  This does happen and causes failures on cocircular points
				x=x0;
			if (x >= x0)  // later than the sweep line
			{
				Point o = new Point(px, py);
				Event e = new Event(o, ax, x);
				e.hk = new HashKey(eventHash.getNewKey());
				eventHash.put(e.hk, e);
				ax.event = e;
				siteEventQ.insert(e);
			}
			else
			{
				// if earlier than sweep line, we ignore because it is behind the parabolic front, and therefore
				//   is not involved in an important event.
				if (DEBUG)
			   		System.out.println("check_circle_event :: circle ("+ret[0]+","+ret[1]+")->"+ ret[2] +" is behind sweepline ="+x0);
			}
		}
		// if a circle wasn't created, we do nothing more
	}

	

	/*******************************************************************
	 * @param p The point that is to be intersected with the arc
	 * @param i The arc that the point is intersected with
	 * @return The point of intersection where the point and parabolic arc intersect.
	 * 
	 * Will take a point and an arc (parabola) and create a horizontal line that 
	 * intersects with the arc. That intersection point is returned. This will call intersection
	 * to determine the actual point of the intersection.
	 ******************************************************************/
	final private Point intersect(Point p, Arc i)
	{
		Point result = new Point(0,0);
		if (i.point.x == p.x) 
		{
			return null;
		}

		double a = bb_y0, b = bb_y1;
		if (i.prev != null) 					// Get the intersection of i.prev, i.
			a = intersection(i.prev.point, i.point, p.x).y;
		if (i.next != null) 					// Get the intersection of i.next, i.
			b = intersection(i.point, i.next.point, p.x).y;

		if ((i.prev == null || a <= p.y) && (i.next == null || p.y <= b)) 
		{
			result.y = p.y;

			// Plug it back into the parabolic equation.
			result.x = (i.point.x*i.point.x + (i.point.y-result.y)*(i.point.y-result.y) - p.x*p.x) / (2*i.point.x - 2*p.x);
			if ( (result.y != result.y) || (result.x != result.x) )
				System.out.println("result has a NAN ordinate");
	
			if ((Math.abs(result.x)> 100000000) || (Math.abs(result.y)> 100000000) )
				System.out.println("should use enhanced precision");

			return result;
	 	}
	   
		return null;							// failed to intersect
	}



	/*******************************************************************
	 * @param p0 first point to generate a parabola
	 * @param p1 second point to generate a parabola
	 * @param L_double Location of the sweep line (effects the size of the parabolas and their intersection)
	 * @return The point of intersection
	 * 
	 * This is the more accurate version that uses BigDecimal. Warning! it is very slow.
	 * Calculates the point of intersection of two parabolas generated by two points p0 and p1. L_double is the location
	 *   of the sweep line. As the sweep line moves farther away, the parabolas move farther in the direction of X+ .
	 ******************************************************************/
	final static private Point intersectionEnhancedPrecision(Point p0, Point p1, double L_double)
	{
		Point p = p0;
		
		BigDecimal two = new BigDecimal("2");
		BigDecimal one = new BigDecimal("1");
		BigDecimal four = new BigDecimal("4");
		
		BigDecimal L = new BigDecimal(L_double);
		
		BigDecimal LL = L.multiply(L);
		BigDecimal result_y =null;
		BigDecimal result_x = null;
		
		BigDecimal p0_x = new BigDecimal(p0.x);
		BigDecimal p0_y = new BigDecimal(p0.y);
	
		BigDecimal p1_x = new BigDecimal(p1.x);
		BigDecimal p1_y = new BigDecimal(p1.y);
		
		if (p0.x == p1.x)
		{
			result_y = p0_y.add(p1_y).divide(two,p0_y.scale()+22,BigDecimal.ROUND_HALF_EVEN );	// result_y = (p0.y + p1.y) / 2;
		}
		else if (p1.x == L_double)
		{
			result_y = p1_y;					// result.y = p1.y;
		}
		else if (p0.x == L_double) 
		{
			result_y = p0_y;					// result.y = p0.y;
			p = p1;
		} 
		else 
		{
			// Use the quadratic formula.
//			double z0 = 2*(p0.x - L);
//			double z1 = 2*(p1.x - L);
//			
//	
//			double a = 1/z0 - 1/z1; 
//			double b = -2*(p0.y/z0 - p1.y/z1);
//			double c = (p0.y*p0.y + p0.x*p0.x - LL)/z0
//				   - (p1.y*p1.y + p1.x*p1.x - LL)/z1;
//	
//			result.y = ( -b - Math.sqrt(b*b - 4*a*c) ) / (2*a);

			BigDecimal z0 = p0_x.subtract(L).multiply(two);
			BigDecimal z1 = p1_x.subtract(L).multiply(two);

			BigDecimal t1 = one.divide(z0,z0.scale()+ one.scale()+20,BigDecimal.ROUND_HALF_EVEN  ) ;
			BigDecimal t2 = one.divide(z1,z1.scale()+ one.scale()+20,BigDecimal.ROUND_HALF_EVEN  ) ;
			
			BigDecimal a = t1.subtract(t2);
			
			BigDecimal t7 = p0_y.divide(z0,p0_y.scale()+z0.scale()+20,BigDecimal.ROUND_HALF_EVEN  );
			BigDecimal t8 = p1_y.divide(z1,p1_y.scale()+z1.scale()+20,BigDecimal.ROUND_HALF_EVEN  );
			BigDecimal b = two.negate().multiply( t7.subtract(t8) );
			
			BigDecimal t3 = p0_y.multiply(p0_y).add( p0_x.multiply(p0_x)).subtract(LL);
			BigDecimal t4 = p1_y.multiply(p1_y).add( p1_x.multiply(p1_x)).subtract(LL);
			
			BigDecimal t5 = t3.divide(z0,t3.scale()+z0.scale()+20, BigDecimal.ROUND_HALF_EVEN);
			BigDecimal t6 = t4.divide(z1,t4.scale()+z1.scale()+20, BigDecimal.ROUND_HALF_EVEN);
			
			BigDecimal c = t5.subtract(t6);
			
			BigDecimal t9 = b.multiply(b).subtract(c.multiply(a).multiply(four));
			
			BigDecimalSQRT bdsqrt = new BigDecimalSQRT();
		
		
			result_y = b.negate().subtract(bdsqrt.get(t9) ).divide( two.multiply(a), t9.scale() + 20,BigDecimal.ROUND_HALF_EVEN);
		}
		
		// Plug back into  the parabolic equation.
		
		// result.x = (p.x*p.x + (p.y-result.y)*(p.y-result.y) - LL)/(2*p.x-2*L);
		BigDecimal p_x = new BigDecimal(p.x);
		BigDecimal p_y = new BigDecimal(p.y);
		
		BigDecimal t10 = p_x.multiply(p_x).add(p_y.subtract(result_y).multiply(p_y.subtract(result_y))).subtract(LL);
		BigDecimal t11 = two.multiply(p_x).subtract( two.multiply(L));
		
		result_x = t10.divide(t11, t10.scale() + t11.scale()+20, BigDecimal.ROUND_HALF_EVEN );
		

		Point result = new Point(result_x.doubleValue(),result_y.doubleValue());
		return result;								// the point of intersection
	}


	/*******************************************************************
	 * @param p0 first point to generate a parabola
	 * @param p1 second point to generate a parabola
	 * @param L_double Location of the sweep line (effects the size of the parabolas and their intersection)
	 * @return The point of intersection
	 * 
	 * Determines whether or not to use enhanced precision
	 ******************************************************************/
	final private Point intersection(Point p0, Point p1, double L)
	{
		if (useEnhancedPrecisionIntersect  == ALWAYS)
			return intersectionEnhancedPrecision(p0,p1,L);
		else if (useEnhancedPrecisionIntersect  == SOMETIMES)
			return intersectionInaccurate(p0,p1,L,true);
		else 
		return intersectionInaccurate(p0,p1,L,false); //NEVER
	}
	
	
	
	/*******************************************************************
	 * @param p0 First point
	 * @param p1 Second point
	 * @param L current sweepline x position
	 * @param adaptivePrecise true = sometime use adapative precision routines, false = never uses them
	 * @return The point where the two arcs intersect
	 * 
	 * Calculates the point of intersection with two parabolas 
	 * and makes sure that they aren't past the sweepline.
	 ******************************************************************/
	final static  private Point intersectionInaccurate(Point p0, Point p1, double L,boolean adaptivePrecise)
	{
		
		if ( (adaptivePrecise) && ((Math.abs(p0.x)> 100000000) || (Math.abs(p0.y)> 100000000) || (Math.abs(p1.x)> 100000000) || (Math.abs(p1.y)> 100000000) ))
		{
			return intersectionEnhancedPrecision( p0,  p1,  L);
		}
		
		Point result = new Point(0, 0);
		Point p = p0;
		double LL = L*L;
		if (p0.x == p1.x)
			result.y = (p0.y + p1.y) / 2;
		else if (p1.x == L)
			result.y = p1.y;
		else if (p0.x == L) {
			result.y = p0.y;
			p = p1;
		} 
		else 
		{
			// Use the quadratic formula.
			double z0 = 2*(p0.x - L);
			double z1 = 2*(p1.x - L);
			
	
			double a = 1/z0 - 1/z1; 
			double b = -2*(p0.y/z0 - p1.y/z1);
			double c = (p0.y*p0.y + p0.x*p0.x - LL)/z0
				   - (p1.y*p1.y + p1.x*p1.x - LL)/z1;
	
			result.y = ( -b - Math.sqrt(b*b - 4*a*c) ) / (2*a);
		}
		// Plug back into one of the parabola equations.
		result.x = (p.x*p.x + (p.y-result.y)*(p.y-result.y) - LL)/(2*p.x-2*L);
		
		if ( (result.x != result.x) || (result.y != result.y) )
			System.out.println("NaN");			// not a number
			
		if ( (adaptivePrecise) && ((Math.abs(result.x)> 100000000) || (Math.abs(result.y)> 100000000) ))
			return intersectionEnhancedPrecision( p0,  p1,  L);

		return result;					// the point of intersection
	}


	/*******************************************************************
	 * Finish off each segment if it hasn't been matched up.
	 * 
	 *  Call finish() on the outstanding segments with the sweepline location being very large
	 ******************************************************************/
	private void finish_edges()
	{
		// Advance the sweep line so no parabolas can cross the bounding box.
		double L = bb_x1 + (bb_x1-bb_x0) + (bb_y1-bb_y0)+ 100000;

		// Extend each remaining segment to the new parabola intersections.
		Arc current = (Arc)arcHash.get(arcRoot.hk);
		while (current != null)
		{
			Arc ac = current;
			if (ac.s1 != null)
			{
				Arc acn = ac.next;
				Segment sx = ac.s1;
				sx.finish(intersection(ac.point, acn.point, L*2));			
			}
			if (current.next == null)
				current = null;
			else
				current = current.next;
			
		}
	}
	
	
	/*******************************************************************
	 * @param s Segment that is to be checked
	 * @return true if the segment is in the bounding box
	 * 
	 * Checks to see if a segment is inside the bounding box. The bounding box 
	 * is created when the initial points are inserted.
	 ******************************************************************/
	private boolean inBoundary(Segment s)
	{
		if (noOutsideEdges)
		{
			if (s.p1.x < bb_x0 || s.p1.x > bb_x1 || s.p1.y < bb_y0 || s.p1.y > bb_y1)
				if (s.p2.x < bb_x0 || s.p2.x > bb_x1 || s.p2.y < bb_y0 || s.p2.y > bb_y1)
					return false;
		}
		return true;
	}
	
	
	/*******************************************************************
	 * @return Returns every segment in skeletonSegsHK  
	 * 
	 * The list of segments that are designated skeletons, specified by "keepMe", 
	 * or aren't generated by two points that have the same "metaNum".
	 ******************************************************************/
	public ArrayList get_output()
	{
		if (returnAll)
			return get_outputfull();
		ArrayList out = new ArrayList(skeletonSegsHK.size());
		for (int i=0; i<skeletonSegsHK.size(); i++)
		{
			out.add((Segment)segHash.get((HashKey)skeletonSegsHK.get(i)));
		}
		
		return out;
	}
	
	
	/*******************************************************************
	 * @return an ArrayList of every segment
	 ******************************************************************/
	public ArrayList get_outputfull()
	{	
	 	return new ArrayList(segHash.values());	
	}
	

}
